image: 'vikadata/dind-aws-node'
services:
  - name: vikadata/dind-aws-node
    command: ['--registry-mirror=https://nt14bg6k.mirror.aliyuncs.com']

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/

variables:
  DOCKER_TLS_CERTDIR: '/certs'
  DOCKER_DRIVER: overlay2
  DOCKER_HOST: 'tcp://vikadata__dind-aws-node:2375'
  SERVICE_NAME: room-server-service
  AWS_ECR_REPOSITORY: '535167499643.dkr.ecr.cn-northwest-1.amazonaws.com.cn'
  AWS_DEFAULT_REGION: 'cn-northwest-1'
  BUCKET_NAME: s.vika.cn
  #容器云域名地址，变量存储在Gitlab
  VIP: $VIP
  #向容器云部署服务的接口地址，变量存储在Gitlab
  SERVER_PATH: $SERVER_DEPLOY_PATH

# 预定义公用脚本
# tag触发
.only-tags: &only-tags
  only:
    refs:
      - tags

stages:
  - build
  - deploy_release
  - merge

# teamx build 阶段：部署socket-sever
build_teamx_node:
  stage: build
  variables:
    #镜像仓库地址
    ECR_REPOSITORY: "cargo.vikadata.com/system-tenant_test2"
    #分区名称
    PARTITION: integration
    #集群名称
    CLUSTER_NAME: compass-stack
    #租户
    TENANT: system-tenant
    #应用服务【标识】，注意不是服务【名称】！！
    APP_NAME: socket-server
    # namespace
    NAMESPACE: teamx
    # 部署服务与eks集群的工作负载名称一致
    DEPLOY_NAME: socket-server-v1
  only:
    - integration
  before_script:
    - docker info
    # 容器云平台登录认证，登录账户、密码与ECR地址存储在Gitlab Group变量中
    - docker login -u $ECR_LOGIN_NAME -p $ECR_PASSWORD $ECR_PATH
    - echo "登录成功"
    # 每次运行的commit Sha
    - IMAGE_TAG=$(echo $CI_COMMIT_SHORT_SHA)
  script:
    - ls -l
    - pwd
    # 构建Docker镜像，推送到镜像仓库
    - BUILD_IMAGE_NAME=$(echo ${ECR_REPOSITORY}/${APP_NAME})
    - docker pull $BUILD_IMAGE_NAME:latest || true
    - docker build --cache-from $BUILD_IMAGE_NAME:latest --tag $BUILD_IMAGE_NAME:$IMAGE_TAG --tag $BUILD_IMAGE_NAME:latest .
    - docker push $BUILD_IMAGE_NAME:$IMAGE_TAG
    - docker push $BUILD_IMAGE_NAME:latest
    # 在容器云控制台创建好容器cluster集群、应用分区
    - echo "开始更新服务"
    - echo "当前更新的版本号：" $IMAGE_TAG
#    - curl -H 'Content-Type:application/json' -X POST -d '{"vip":"'"$VIP"'","clusters":"'"$CLUSTER_NAME"'","partition":"'"$PARTITION"'","appName":"'"$APP_NAME"'","tenant":"'"$TENANT"'","newVersion":"'"$IMAGE_TAG"'"}' ${SERVER_PATH}/deploy/compass
    # 使用deploy-server.py脚本，调用容器云接口自动部署最新镜像并更新服务
#     - python3 deploy-server.py $VIP $CLUSTER_NAME $PARTITION $APP_NAME $TENANT $IMAGE_TAG
    # 部署eks集群
    - DEPLOY_SERVER="$DEPLOY_SERVER_INTEGRATION"
    - echo "部署服务器：" $DEPLOY_SERVER  "更新对应集群：" $EKS_SERVER  "对应项目：" $NAMESPACE  "对应服务：" $DEPLOY_NAME "当前更新镜像：" $BUILD_IMAGE_NAME:$IMAGE_TAG
    - python3 deploy-eks.py $DEPLOY_SERVER $EKS_SERVER $NAMESPACE $DEPLOY_NAME $BUILD_IMAGE_NAME:$IMAGE_TAG
    - echo "完成更新"
  when: manual

# integration build 阶段：部署socket-sever
build_integration_node:
  stage: build
  variables:
    #镜像仓库地址
    ECR_REPOSITORY: "cargo.vikadata.com/system-tenant_integration"
    #分区名称
    PARTITION: integration
    #集群名称
    CLUSTER_NAME: compass-stack
    #租户
    TENANT: system-tenant
    #应用服务【标识】，注意不是服务【名称】！！
    APP_NAME: socket-server
    # namespace
    NAMESPACE: integration
    # 部署服务与eks集群的工作负载名称一致
    DEPLOY_NAME: socket-server-v1
  only:
    - integration
  before_script:
    - docker info
    # 容器云平台登录认证，登录账户、密码与ECR地址存储在Gitlab Group变量中
    - docker login -u $ECR_LOGIN_NAME -p $ECR_PASSWORD $ECR_PATH
    - echo "登录成功"
    # 每次运行的commit Sha
    - IMAGE_TAG=$(echo $CI_COMMIT_SHORT_SHA)
  script:
    - ls -l
    - pwd
    # 构建Docker镜像，推送到镜像仓库
    - BUILD_IMAGE_NAME=$(echo ${ECR_REPOSITORY}/${APP_NAME})
    - docker pull $BUILD_IMAGE_NAME:latest || true
    - docker build --cache-from $BUILD_IMAGE_NAME:latest --tag $BUILD_IMAGE_NAME:$IMAGE_TAG --tag $BUILD_IMAGE_NAME:latest .
    - docker push $BUILD_IMAGE_NAME:$IMAGE_TAG
    - docker push $BUILD_IMAGE_NAME:latest
    # 在容器云控制台创建好容器cluster集群、应用分区
    - echo "开始更新服务"
    - echo "当前更新的版本号：" $IMAGE_TAG
#    - curl -H 'Content-Type:application/json' -X POST -d '{"vip":"'"$VIP"'","clusters":"'"$CLUSTER_NAME"'","partition":"'"$PARTITION"'","appName":"'"$APP_NAME"'","tenant":"'"$TENANT"'","newVersion":"'"$IMAGE_TAG"'"}' ${SERVER_PATH}/deploy/compass
    # 使用deploy-server.py脚本，调用容器云接口自动部署最新镜像并更新服务
#     - python3 deploy-server.py $VIP $CLUSTER_NAME $PARTITION $APP_NAME $TENANT $IMAGE_TAG
    # 部署eks集群
    - DEPLOY_SERVER="$DEPLOY_SERVER_INTEGRATION"
    - echo "部署服务器：" $DEPLOY_SERVER  "更新对应集群：" $EKS_SERVER  "对应项目：" $NAMESPACE  "对应服务：" $DEPLOY_NAME "当前更新镜像：" $BUILD_IMAGE_NAME:$IMAGE_TAG
    - python3 deploy-eks.py $DEPLOY_SERVER $EKS_SERVER $NAMESPACE $DEPLOY_NAME $BUILD_IMAGE_NAME:$IMAGE_TAG
    - echo "完成更新"


# staging build 阶段：部署socket Server
build_staging _node:
  stage: build
  variables:
    #镜像仓库地址
    ECR_REPOSITORY: "cargo.vikadata.com/system-tenant_staging"
    #分区名称
    PARTITION: staging
    #集群名称
    CLUSTER_NAME: compass-stack
    #租户
    TENANT: system-tenant
    #应用服务【标识】，注意不是服务【名称】！！
    APP_NAME: socket-server-staging
    # namespace
    NAMESPACE: staging
    # 部署服务与eks集群的工作负载名称一致
    DEPLOY_NAME: socket-server-v1
  only:
    - staging
  before_script:
    - docker info
    # 容器云平台登录认证，登录账户、密码与ECR地址存储在Gitlab Group变量中
    - docker login -u $ECR_LOGIN_NAME -p $ECR_PASSWORD $ECR_PATH
    - echo "登录成功"
    # 每次运行的commit Sha
    - IMAGE_TAG=$(echo $CI_COMMIT_SHORT_SHA)
  script:
    - ls -l
    - pwd
    # 构建Docker镜像，推送到镜像仓库
    - BUILD_IMAGE_NAME=$(echo ${ECR_REPOSITORY}/${APP_NAME})
    - docker pull $BUILD_IMAGE_NAME:latest || true
    - docker build --cache-from $BUILD_IMAGE_NAME:latest --tag $BUILD_IMAGE_NAME:$IMAGE_TAG --tag $BUILD_IMAGE_NAME:latest .
    - docker push $BUILD_IMAGE_NAME:$IMAGE_TAG
    - docker push $BUILD_IMAGE_NAME:latest
    # 在容器云控制台创建好容器cluster集群、应用分区
    - echo "开始更新服务"
    - echo "当前更新的版本号：" $IMAGE_TAG
#    - curl -H 'Content-Type:application/json' -X POST -d '{"vip":"'"$VIP"'","clusters":"'"$CLUSTER_NAME"'","partition":"'"$PARTITION"'","appName":"'"$APP_NAME"'","tenant":"'"$TENANT"'","newVersion":"'"$IMAGE_TAG"'"}' ${SERVER_PATH}/deploy/compass
    # 使用deploy-server.py脚本，调用容器云接口自动部署最新镜像并更新服务
    # - python3 deploy-server.py $VIP $CLUSTER_NAME $PARTITION $APP_NAME $TENANT $IMAGE_TAG
    # 部署eks集群
    - DEPLOY_SERVER="$DEPLOY_SERVER_INTEGRATION"
    - python3 deploy-eks.py $DEPLOY_SERVER $EKS_SERVER $NAMESPACE $DEPLOY_NAME $BUILD_IMAGE_NAME:$IMAGE_TAG
    - echo "完成更新"

# 正式版本发布部署（node服务），仅限于创建Git Tag标签触发
release_deploy_node:
  <<: *only-tags
  stage: deploy_release
  variables:
    #镜像仓库地址
    ECR_REPOSITORY: "cargo.vikadata.com/vika-prod_release"
    #分区名称
    PARTITION: production
    #集群名称
    CLUSTER_NAME: user-21b785-20200409100351-1a0l
    #租户
    TENANT: vika-prod
    #应用服务【标识】，注意不是服务【名称】！！
    APP_NAME: socket-server
  before_script:
    - docker info
    # 容器云平台登录认证，登录账户、密码与ECR地址存储在Gitlab Group变量中
    - docker login -u $ECR_LOGIN_NAME -p $ECR_PASSWORD $ECR_PATH
    # 每次运行的commit Sha
    - IMAGE_TAG=$(echo $CI_COMMIT_SHORT_SHA)
  script:
    - ls -l
    - pwd
    # 构建Docker镜像，推送到镜像仓库
    - BUILD_IMAGE_NAME=$(echo ${ECR_REPOSITORY}/${APP_NAME})
    - docker pull $BUILD_IMAGE_NAME:latest || true
    - docker build --cache-from $BUILD_IMAGE_NAME:latest --tag $BUILD_IMAGE_NAME:$IMAGE_TAG --tag $BUILD_IMAGE_NAME:latest .
    - docker push $BUILD_IMAGE_NAME:$IMAGE_TAG
    - docker push $BUILD_IMAGE_NAME:latest
    # 在容器云控制台创建好容器cluster集群、应用分区
    - echo "开始更新服务"
    - echo "当前更新的版本号：" $IMAGE_TAG
#    - curl -H 'Content-Type:application/json' -X POST -d '{"vip":"'"$VIP"'","clusters":"'"$CLUSTER_NAME"'","partition":"'"$PARTITION"'","appName":"'"$APP_NAME"'","tenant":"'"$TENANT"'","newVersion":"'"$IMAGE_TAG"'"}' ${SERVER_PATH}/deploy/compass
    # 使用deploy-server.py脚本，调用容器云接口自动部署最新镜像并更新服务
    - python3 deploy-server.py $VIP $CLUSTER_NAME $PARTITION $APP_NAME $TENANT $IMAGE_TAG
    - echo "完成更新"
  # 手动执行JOB
  when: manual

# 正式版本发布部署（node服务），仅限于创建Git Tag标签触发
release_deploy_ks_node:
  <<: *only-tags
  stage: deploy_release
  variables:
    #镜像仓库地址
    ECR_REPOSITORY: "cargo.vikadata.com/vika-prod_release"
    #分区名称
    PARTITION: production
    #集群名称
    CLUSTER_NAME: user-21b785-20200409100351-1a0l
    #租户
    TENANT: vika-prod
    #应用服务【标识】，注意不是服务【名称】！！
    APP_NAME: socket-server
    # 项目名称
    NAMESPACE: production
    # 工作负载名称
    DEPLOY_NAME: socket-server-v1
  before_script:
    - docker info
    # 容器云平台登录认证，登录账户、密码与ECR地址存储在Gitlab Group变量中
    - docker login -u $ECR_LOGIN_NAME -p $ECR_PASSWORD $ECR_PATH
    # 每次运行的commit Sha
    - IMAGE_TAG=$(echo $CI_COMMIT_SHORT_SHA)
  script:
    - ls -l
    - pwd
    # 构建Docker镜像，推送到镜像仓库
    - BUILD_IMAGE_NAME=$(echo ${ECR_REPOSITORY}/${APP_NAME})
    - docker pull $BUILD_IMAGE_NAME:latest || true
    - docker build --cache-from $BUILD_IMAGE_NAME:latest --tag $BUILD_IMAGE_NAME:$IMAGE_TAG --tag $BUILD_IMAGE_NAME:latest .
    - docker push $BUILD_IMAGE_NAME:$IMAGE_TAG
    - docker push $BUILD_IMAGE_NAME:latest
    # 在容器云控制台创建好容器cluster集群、应用分区
    - echo "开始更新服务"
    - echo "当前更新的版本号：" $IMAGE_TAG
    # 部署eks集群
    - DEPLOY_SERVER="$DEPLOY_SERVER_PRODUCTION"
    - EKS_SERVER=https://DD0A14D35441423ADC840071E0926891.sk1.cn-northwest-1.eks.amazonaws.com.cn
    - echo "部署服务器：" $DEPLOY_SERVER  "更新对应集群：" $EKS_SERVER  "对应项目：" $NAMESPACE  "对应服务：" $DEPLOY_NAME "当前更新镜像：" $BUILD_IMAGE_NAME:$IMAGE_TAG
    - python3 deploy-eks.py $DEPLOY_SERVER $EKS_SERVER $NAMESPACE $DEPLOY_NAME $BUILD_IMAGE_NAME:$IMAGE_TAG
    - echo "完成更新"
  # 手动执行JOB
  when: manual


# test build 阶段：部署socket-sever
build_test_node:
  stage: build
  variables:
    #镜像仓库地址
    ECR_REPOSITORY: "cargo.vikadata.com/system-tenant_test"
    #分区名称
    PARTITION: integration
    #集群名称
    CLUSTER_NAME: compass-stack
    #租户
    TENANT: system-tenant
    #应用服务【标识】，注意不是服务【名称】！！
    APP_NAME: socket-test
    # namespace
    NAMESPACE: test
    # 部署服务与eks集群的工作负载名称一致
    DEPLOY_NAME: socket-server-v1
  only:
    - test
  before_script:
    - docker info
    # 容器云平台登录认证，登录账户、密码与ECR地址存储在Gitlab Group变量中
    - docker login -u $ECR_LOGIN_NAME -p $ECR_PASSWORD $ECR_PATH
    - echo "登录成功"
    # 每次运行的commit Sha
    - IMAGE_TAG=$(echo $CI_COMMIT_SHORT_SHA)
  script:
    - ls -l
    - pwd
    # 构建Docker镜像，推送到镜像仓库
    - BUILD_IMAGE_NAME=$(echo ${ECR_REPOSITORY}/${APP_NAME})
    - docker pull $BUILD_IMAGE_NAME:latest || true
    - docker build --cache-from $BUILD_IMAGE_NAME:latest --tag $BUILD_IMAGE_NAME:$IMAGE_TAG --tag $BUILD_IMAGE_NAME:latest .
    - docker push $BUILD_IMAGE_NAME:$IMAGE_TAG
    - docker push $BUILD_IMAGE_NAME:latest
    # 在容器云控制台创建好容器cluster集群、应用分区
    - echo "开始更新服务"
    - echo "当前更新的版本号：" $IMAGE_TAG
#    - curl -H 'Content-Type:application/json' -X POST -d '{"vip":"'"$VIP"'","clusters":"'"$CLUSTER_NAME"'","partition":"'"$PARTITION"'","appName":"'"$APP_NAME"'","tenant":"'"$TENANT"'","newVersion":"'"$IMAGE_TAG"'"}' ${SERVER_PATH}/deploy/compass
    # 使用deploy-server.py脚本，调用容器云接口自动部署最新镜像并更新服务
    # - python3 deploy-server.py $VIP $CLUSTER_NAME $PARTITION $APP_NAME $TENANT $IMAGE_TAG
    # 部署eks集群
    - DEPLOY_SERVER="$DEPLOY_SERVER_INTEGRATION"
    - echo "部署服务器：" $DEPLOY_SERVER  "更新对应集群：" $EKS_SERVER  "对应项目：" $NAMESPACE  "对应服务：" $DEPLOY_NAME "当前更新镜像：" $BUILD_IMAGE_NAME:$IMAGE_TAG
    - python3 deploy-eks.py $DEPLOY_SERVER $EKS_SERVER $NAMESPACE $DEPLOY_NAME $BUILD_IMAGE_NAME:$IMAGE_TAG
    - echo "完成更新"

# 私有化 build 阶段：部署socket-sever
private_build_node:
  stage: build
  variables:
    #镜像仓库地址
    ECR_REPOSITORY: "cargo.vikadata.com/system-tenant_private"
    #租户
    TENANT: system-tenant
    #应用服务【标识】，注意不是服务【名称】！！
    APP_NAME: socket-server
  only:
    - integration
    - staging
  before_script:
    - docker info
    # 容器云平台登录认证，登录账户、密码与ECR地址存储在Gitlab Group变量中
    - docker login -u $ECR_LOGIN_NAME -p $ECR_PASSWORD $ECR_PATH
    - echo "登录成功"
    # 直接获取tag Name
    # - IMAGE_TAG=$(echo $CI_COMMIT_TAG | sed 's/\"//g'|sed 's/ //g')
    - IMAGE_TAG=$(if [ "$CI_COMMIT_TAG" == "" ];then echo ${VERSION_TAG}-private.${CI_PIPELINE_ID}; else echo $CI_COMMIT_TAG | sed 's/\"//g'|sed 's/ //g';fi)
  script:
    - ls -l
    - pwd
    # 构建Docker镜像，推送到镜像仓库
    - BUILD_IMAGE_NAME=$(echo ${ECR_REPOSITORY}/${APP_NAME})
    - docker pull $BUILD_IMAGE_NAME:latest || true
    - docker build --cache-from $BUILD_IMAGE_NAME:latest --tag $BUILD_IMAGE_NAME:$IMAGE_TAG --tag $BUILD_IMAGE_NAME:latest . -f Dockerfile.private
    - echo "同步保存镜像到私有化目录：/home/private"
    - mkdir -p /home/private/${VERSION_TAG}-${CI_PIPELINE_ID}
    - docker save $BUILD_IMAGE_NAME:latest -o /home/private/${VERSION_TAG}-${CI_PIPELINE_ID}/socket-server-${VERSION_TAG}-${CI_PIPELINE_ID}.tar
    - docker push $BUILD_IMAGE_NAME:$IMAGE_TAG
    - docker push $BUILD_IMAGE_NAME:latest
    - echo "当前更新的版本号：" $IMAGE_TAG
    - echo "完成更新"
  when: manual
